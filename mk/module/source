## 
##  metakit -- the extensible meta-build system
##  Copyright (C) Brian Koropoff
## 
##  This program is free software; you can redistribute it and/or
##  modify it under the terms of the GNU General Public License
##  as published by the Free Software Foundation; either version 2
##  of the License, or (at your option) any later version.
## 
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
## 
##  You should have received a copy of the GNU General Public License
##  along with this program; if not, write to the Free Software
##  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
## 
##  The source code contained within this file is also subject to the
##  following additional terms:
## 
##  1. "Program" below refers to metakit or any derivative work thereof
##     under copyright law. "Unmodified" below refers to the Program
##     prior to any modification by the licensee, in a form which was
##     distributed while fully abiding by the terms of the GNU General
##     Public License and these additional clauses. "Unmodified Version"
##     refers to the Unmodified Program or the portion thereof from which
##     the licensee's modified version is derived.  Each licensee is
##     addressed as "you."
## 
##  2. As a special exception to the terms of the GNU General Public License,
##     you are granted unlimited permission to copy, distribute, and modify
##     the output of the Program, even when such output contains portions
##     of the Program source code which are otherwise governed by the terms
##     of the GNU General Public License.  When distributing a modified
##     version of the Program, you may choose to extend this special
##     exception to your modified version as well.
## 
##  3. The exception in clause 2 applies only to portions of the Program which
##     appear in a file containing these additional clauses.  You may not
##     extend this exception to portions of the Program which are contained
##     in a file that does not contain these clauses.  In addition, you may
##     not extend the exception to your modified version under any of the
##     following circumstances:
## 
##     a)  You move, copy, combine, or otherwise modify portions of the
##         Program such that a file is produced which:
##         
##         i.  Contains portions of the Program which, in the Unmodified
##             Version, were contained in a file which contained these
##             additional clauses; and
## 
##         ii. Contains portions of the Program which, in the Unmodified
##             Version, were contained in a file which did not contain these
##             additional clauses.
## 
##     b)  You modify the behavior of the Program such that it may copy portions
##         of the Program into its output where said portions, in the Unmodified
##         Version, were contained in a file which did not contain these clauses.
## 
##  4.  If any of the circumstances in clause 3 apply, you must remove these clauses
##      from the affected portions of your version of the Program in order to
##      distribute it.  In the case of (3.i), this means the offending file which
##      contains the inappropriately combined portions of the Program.  In the case
##      of (3.ii), it means the entirety of the Program.
##

# This module defines the basic build strategy for source components
DEPENDS="mk"
PHASES="prepare build stage install clean dist"
VIRTUALS="clean install all dist"

PHASE_PREPARE='once: stage-%{DEPENDS}'
PHASE_BUILD='once: prepare-%{NAME} $(MK_DEPS_%{NAME})'
PHASE_STAGE='once: build-%{NAME}'
PHASE_INSTALL='always: stage-%{NAME}: "$(DESTDIR)"'
PHASE_CLEAN='always'
PHASE_DIST='always: prepare-%{NAME}'
VIRTUAL_CLEAN="clean-%{COMPONENTS}"
VIRTUAL_INSTALL="install-%{COMPONENTS}"
VIRTUAL_ALL="stage-%{COMPONENTS}"
VIRTUAL_DIST="dist-%{COMPONENTS}"

load()
{
    MK_SOURCE_DIRNAME="source"
    MK_BUILD_DIRNAME="build"
    MK_STAGE_DIRNAME="stage"
    MK_DIST_DIRNAME="dist"
    MK_SOURCE_DIR="${MK_ROOT_DIR}/${MK_SOURCE_DIRNAME}"
    MK_STAGE_DIR="${MK_WORK_DIR}/${MK_STAGE_DIRNAME}"
    MK_BUILD_DIR="${MK_WORK_DIR}/${MK_BUILD_DIRNAME}"
    MK_DIST_DIR="${MK_WORK_DIR}/${MK_DIST_DIRNAME}"

    mk_set_comp_vars()
    {
	__sourcedir="`mk_get_component_var "${1}" "SOURCE_DIR"`"
	[ -z "${__sourcedir}" ] && __sourcedir="${1}"

	MK_COMP_SOURCE_DIR="${MK_SOURCE_DIR}/${__sourcedir}"
	MK_COMP_STAGE_DIR="${MK_STAGE_DIR}/$1"
	MK_COMP_BUILD_DIR="${MK_BUILD_DIR}/$1"
    }

    # Simple function that installs all files in a component
    # for use in the install() step
    mk_install_all()
    {
	mk_log "Installing files from staging area"
	mk_log_enter "file"
	( cd "${MK_COMP_STAGE_DIR}" && find . | sed 's:^./::g' | grep -v '^\.$') | mk_log_pipe
	mk_log_leave
	mkdir -p "${MK_COMP_INSTALL_DIR}/${MK_PREFIX}" || mk_fail "could not create install directory"
	mk_sync "${MK_COMP_STAGE_DIR}/${MK_PREFIX}/" "${MK_COMP_INSTALL_DIR}/${MK_PREFIX}/" || mk_fail "could not sync files"
    }

    mk_copy_source()
    {
	mk_log "Copying source"
	mk_sync "${MK_COMP_SOURCE_DIR}/" "${MK_COMP_BUILD_DIR}/" || mk_fail "could not copy source code"
    }

    mk_get_stage_dir()
    {
	echo "${MK_STAGE_DIR}/${1}"
    }

    __mk_backup_includes()
    {
	if [ -d "${MK_COMP_STAGE_DIR}/${MK_PREFIX}/.include" ]
	then
	    mk_safe_rm "${MK_COMP_STAGE_DIR}/${MK_PREFIX}/.include"
	fi

	if [ -d "${MK_COMP_STAGE_DIR}/${MK_PREFIX}/include" ]
	then
	    mv "${MK_COMP_STAGE_DIR}/${MK_PREFIX}/include" "${MK_COMP_STAGE_DIR}/${MK_PREFIX}/.include"
	fi
    }

    __mk_merge_includes()
    {
	__include="${MK_COMP_STAGE_DIR}/${MK_PREFIX}/include"
	__dot_include="${MK_COMP_STAGE_DIR}/${MK_PREFIX}/.include"

	if [ -d "$__dot_include" ]
	then
	    mk_log "Preserving timestamps"
	    mk_log_enter "file"
	    (
		cd "$__include"
		for __file in `find *`
		do
		    if [ -f "${__include}/${__file}" -a -f "${__dot_include}/${__file}" ] && \
			diff -q "${__include}/${__file}" "${__dot_include}/${__file}" >/dev/null 2>&1
		    then
			mk_log "${__file}"
			mv "${__dot_include}/${__file}" "${__include}/${__file}"
		    fi
		done
	    )
	    mk_log_leave
	    mk_safe_rm "${__dot_include}"
	fi
    }
}

output()
{
    for dir in ${MK_BUILD_DIRNAME} ${MK_STAGE_DIRNAME} ${MK_DIST_DIRNAME}
    do
	mk_log "Creating directory ${dir}"
	mkdir -p "${MK_WORK_DIR}/${dir}"
    done
}

pre_init()
{
    mk_set_comp_vars "${MK_COMP}"
    
    [ -d "${MK_COMP_SOURCE_DIR}" ] || mk_fail "Could not find source directory for ${MK_COMP}"

    cd "${MK_COMP_SOURCE_DIR}"
}

pre_prepare()
{
    mk_set_comp_vars "${MK_COMP}"

    mkdir -p "$MK_COMP_BUILD_DIR" || mk_fail "could not create component build directory"
    cd "$MK_COMP_BUILD_DIR" || mk_fail "could not change to component build directory"
}

pre_build()
{
    mk_set_comp_vars "${MK_COMP}"
    cd "$MK_COMP_BUILD_DIR" || mk_fail "could not change to component build directory"
}

pre_stage()
{
    mk_set_comp_vars "${MK_COMP}"

    mkdir -p "$MK_COMP_STAGE_DIR" || mk_fail "could not create component build directory"

    __mk_backup_includes

    cd "$MK_COMP_BUILD_DIR" || mk_fail "could not change to component build directory"
}

post_stage()
{
    __mk_merge_includes
}

pre_dist()
{
    mk_set_comp_vars "${MK_COMP}"
    cd "$MK_COMP_BUILD_DIR" || mk_fail "could not change to component build directory"
}

pre_install()
{
    mk_set_comp_vars "${MK_COMP}"

    MK_COMP_INSTALL_DIR="$1"

    mkdir -p "${MK_COMP_INSTALL_DIR}" || mk_fail "could not create install directory"

    cd "$MK_COMP_STAGE_DIR" || mk_fail "could not change to component stage directory"
}

pre_clean()
{
    mk_set_comp_vars "${MK_COMP}"
}

default_install()
{
    mk_install_all
}

default_clean()
{
    mk_log "Cleaning directories"
    mk_log_enter "dir"
    for _dir in "${MK_COMP_STAGE_DIR}" "${MK_COMP_BUILD_DIR}"
    do
	if [ -d "${_dir}" ]
	then
	    mk_log "${_dir##$MK_WORK_DIR/}"
	    mk_safe_rm "${_dir}"
	fi
    done
    mk_log_leave "dir"
    mk_log "Cleaning files"
    mk_log_enter "file"
    for _file in "${MK_TARGET_DIR}/"*"-${MK_COMP}"
    do
	if [ -f "${_file}" ]
	then
	    mk_log "${_file##$MK_WORK_DIR/}"
	    mk_safe_rm "${_file}"
	fi
    done
    mk_log_leave
}

virtual_dist()
{
    mk_log "Completed dist"
}